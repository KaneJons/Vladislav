#include <iostream> // Подключение библиотеки для ввода-вывода.
#include <malloc.h> // Подключение библиотеки для работы с динамическим выделением памяти.

using namespace std; // Использование пространства имён std для упрощения синтаксиса (например, вместо std::cout можно писать cout).

int main() {
    setlocale(LC_ALL, "Russian"); // Установка локализации, чтобы текст на русском языке корректно отображался в консоли.
    int k, p; // Переменные для хранения количества строк и столбцов матрицы.

    // Инициализация переменных для подсчёта положительных, отрицательных и нулевых элементов.
    int posCount = 0, negCount = 0, zeroCount = 0;

    // Ввод количества строк и столбцов матрицы от пользователя.
    cout << "Введите количество строк и столбцов матрицы: ";
    cin >> k >> p;

    // Динамическое выделение памяти для двумерного массива (матрицы).
    // Создаётся массив указателей, каждый из которых будет указывать на строки.
    int** F = (int**)calloc(k, sizeof(int*));
    for (int i = 0; i < k; i++) {
        // Для каждой строки выделяется память под массив целых чисел (столбцы).
        F[i] = (int*)calloc(p, sizeof(int));
    }

    // Заполнение матрицы элементами, вводимыми пользователем.
    cout << "Введите элементы матрицы:\n";
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < p; j++) {
            cin >> F[i][j]; // Ввод элемента матрицы на позицию (i, j).
        }
    }


    // Вывод исходной матрицы на экран.
    cout << "Исходная матрица:\n";
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < p; j++) {
            cout << F[i][j] << "\t"; // Вывод элемента с табуляцией для форматирования.

            // Подсчёт количества положительных, отрицательных и нулевых элементов.
            if (F[i][j] > 0) posCount++;
            else if (F[i][j] < 0) negCount++;
            else zeroCount++;
        }
        cout << endl; // Переход на следующую строку после вывода всех столбцов текущей строки.
    }

    int temp; // Переменная для временного хранения значения при обмене элементов.

    // Обработка матрицы: нахождение максимального и минимального элементов.
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < p; j++) {
            // Если текущий элемент больше первого элемента матрицы, выполняется их замена.
            if (F[i][j] > F[0][0]) {
                temp = F[0][0];
                F[0][0] = F[i][j];
                F[i][j] = temp;
            }

            // Если текущий элемент меньше последнего элемента матрицы, выполняется их замена.
            if (F[i][j] < F[k - 1][p - 1]) {
                temp = F[k - 1][p - 1];
                F[k - 1][p - 1] = F[i][j];
                F[i][j] = temp;
            }
        }
    }

    // Вывод обработанной матрицы на экран.
    cout << "Обработанная матрица:\n";
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < p; j++) {
            cout << F[i][j] << "\t"; // Вывод элемента с табуляцией.
        }
        cout << endl; // Переход на новую строку.
    }

    // Вывод количества положительных, отрицательных и нулевых элементов.
    cout << "Количество положительных элементов: " << posCount << endl;
    cout << "Количество отрицательных элементов: " << negCount << endl;
    cout << "Количество нулевых элементов: " << zeroCount << endl;

    // Освобождение памяти, выделенной для матрицы.
    for (int i = 0; i < k; i++) {
        free(F[i]); // Освобождение памяти, выделенной под текущую строку.
    }
    free(F); // Освобождение памяти, выделенной под массив указателей на строки.

    return 0; // Завершение программы с кодом успешного выполнения.
}
